# 算法学习笔记

## 零. 算法基础

### 1. 枚举

就是一个一个试，其精髓在于如何优化测试，使其在更小的时空复杂度上解决问题

衍生算法：搜索等

优化要点：缩小解的枚举范围（如剪枝），选择合适的枚举顺序（如求给定区间的最大素数从最大的数开始枚举）

### 2. 模拟

模拟就是用计算机模拟题目中的情景，其代码量大，且需要考虑方方面面，比较繁琐

注意事项：将程序模块化，尽量少在main函数里进行复杂操作，使代码逻辑更加清晰。

### 3. 递归和分治

递归：在函数的定义中使用函数自身的方法，或通过重复将问题分解为同类的子问题而解决问题的方法

递归的要点：确定递归边界，避免死递归。减小递归深度，避免爆栈。

递归模板：

``` C++
int recursion(int arg)
{
    if (/*递归边界条件*/)
        return /*最小子问题解*/;
    return recursion(/*子问题的参数*/);
}
```

分治：分治算法的核心思想就是“分而治之”。

大概的流程可以分为三步：分解 -> 解决 -> 合并。

1. 分解原问题为结构相同的子问题。
2. 分解到某个容易求解的边界之后，进行递归求解。
3. 将子问题的解合并成原问题的解。

分治法能解决的问题一般有如下特征：

- 该问题的规模缩小到一定的程度就可以容易地解决。

- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。

- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

``` C++
int conquer(_args)
{
   if (/*达到问题的最小规模*/)
       return /*最小子问题的解*/;
   conquer(sub) 
}
```



### 6. 前缀和&差分

用于预处理数列，可以降低查询的时间复杂度。

前缀和即“数列的前n项和”





（挖坑待填:sleeping:）

## 一. 搜索

### 0. 搜索的基本流程

搜索算法的基本框架都差不多，最大的区别就是用来存储即将访问节点的容器不同。我们将这个容器称为 **openlist**。

基本框架

```
_type openlist

void search(_type depth,)
{
	
}
```



### 1. 深度优先搜索（非图论）

使用栈保存未被检测的状态，状态按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。

本质上是一种~~优雅的~~枚举。DFS使用递归，隐含地使用了系统的栈，不需要自己维护一个数据结构。

时间复杂度较高但空间复杂度较低，可以进行优化。

基本结构：

``` C++
void dfs(_type step)
{
    //判断是否满足结束条件
    if (/*结果判断*/)
    {
        /*输出解*/
        return;
    }
    //循环枚举待验证解
    for(int i(0) ; i < /*需要枚举的节点总数*/ ; i++)
    {
        if (mark[i] == false && /*是否满足进入下一层的条件*/)
        {
        	mark[i] = true;		//标记枚举过的节点
        	dfs(step+1);		//进行下一层枚举
        	mark[i] = false;	//还原枚举过的节点
        }
    }
    return;
}
```

优点：能找出所有方案，代码比BFS简洁许多。

缺点：在搜索层数较深的情况下时间复杂度高，递归过深容易爆栈

优化方法：

[^1]: 参考文章：[浅谈搜索剪枝 - Fenghr - 博客园 (cnblogs.com)](https://www.cnblogs.com/fenghaoran/p/6391016.html)

1. 可行性剪枝：

   当前条件不合法时就不再继续搜索，直接`return;`

2. 最优性剪枝：

   利用某个函数估计出此时条件下答案的当前最值，如果当前条件所花费的代价已经超过了当前搜索到的最优解，那么剩下的搜索就可以剪掉。

3. 记忆化搜索：

   如果对于相同情况下答案相同的情况，可以先把这个情况的答案存储下来，以后搜索时直接调用，避免重复搜索。

4. 搜索顺序剪枝

   预先估计搜索效率最高的顺序，从效率最高处开始搜索。

   迷宫、网格类：从出口向入口搜索

   推断搜索类：从已知信息最多的地方开始搜索
   
### 2. 广度优先搜索（非图论）

​	使用队列来保存未被检测的状态。状态按照宽度优先的顺序被访问和进出队列。

​	说人话，就是先检测初始状态，若不符合要求则将与初始状态直接相连的状态存入队列，然后从队列前端取出下一个状态进行访问，重复上述操作，直至找出符合要求的状态。

​	注意事项：需要标记已检测的状态，否则可能陷入无限循环检测（如环形图）

​	基本结构：

``` C++
queue q;

void bfs(_type status)
{
    //将初始状态存入队列并标记
	q.push(status);
    status.visited = true;
    while(q.empty() == false)
    {
        //取出欲访问状态，遍历其相邻状态
        status = q.front();
        q.pop();
        for(int i;i < limit;i++)
        {
            if (status.next[i].visited == false)
            {
                q.push(status.next[i]);
            	status.next[i].visited = true;
            }
        }
    }
}
```

（详见图论BFS :hole: )

### 3. 双向搜索



## 二.动态规划

### 0.动态规划基础

动态规划是一种用空间换时间的算法

基本思想：将一个问题分解成若干个子问题，子问题互相重叠，

### 1.背包DP

#### (1) 0-1背包

**已知条件：**第 $i$ 个物品的重量 $w_i$ 和价值 $v_i$ ，以及背包的总容量 $W$

**要求：**选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量

**方法：**

* 设DP状态 $f_{i}$ 为在第 $i$ 个状态下背包中物品所能达到的最大总价值，$j_i$ 为在第 $i$ 个状态下背包的剩余容量

使用递归进行状态转移：

----

每一个状态包括两种情况：选择当前物品和不选择当前物品

* 设已得到前 $i-1$ 个状态的最优解 $f_{i-1}$

对于第 $i$ 个物品，<u>在背包容量大于其重量的前提下</u>

当其不被选择时，背包的剩余容量和其中物品的总价值不变，该情况的背包中物品的总价值为 $f_{i-1}$，剩余容量容量为 $ j_{i-1} $

当其被选择时，背包的剩余容量减少 $w_i$ ，其中物品的总价值增加 $v_i$ ，该情况的背包中物品的总价值为 $f_{i-1} + v_i$，剩余容量为 $j_{i-1} - w_i$

则当前状态的最优解为两种情况中的最大值，即~~状态转移方程~~
$$
f_{i,j} = max(f_{i-1,j} , f_{i-1,j-w_i}+v_i)
$$

当递归完成后，所得结果则为整体的最优解

----

基本结构：

```c++
/*自上而下的递归写法*/
int OIPack(int *value,int *weight,const int num,const int volume)
{
    int result(0);
    if(j >= weight[i])
        result = max(OIPack())
}
/*自底而上的非递归写法*/
int ZeroOnePack(int value[],int weight[],const int num,const int volume)
{
    int dp[num+1][volume+1] = {0};
    for(int i(1); i<=num; i++)
        for(int j(0); j<=volume; j++)
            if(j >= weight[i])/*判断背包的容量是否能够装下第i个物品*/
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);
            else
                dp[i][j]=dp[i-1][j];
    return dp[n][volume];
}
```

优化：由于采用二维数组很容易MLE，我们采用滚动数组的方式压缩空间

滚动数组的原理：DP往往使用的是相邻状态的数据，对于很久~~(并不)~~之前计算的数据无要求，可以舍弃这部分的值，将其空间用来存储新值，达到节省空间的目的





#### (2) 完全背包

