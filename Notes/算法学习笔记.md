# 算法学习笔记

## 零. 算法基础

### 1. 枚举

就是一个一个试，其精髓在于如何优化测试，使其在更小的时空复杂度上解决问题

衍生算法：搜索等

优化要点：缩小解的枚举范围（如剪枝），选择合适的枚举顺序（如求给定区间的最大素数从最大的数开始枚举）

### 2. 模拟

模拟就是用计算机模拟题目中的情景，其代码量大，且需要考虑方方面面，比较繁琐

注意事项：将程序模块化，尽量少在main函数里进行复杂操作，使代码逻辑更加清晰。

### 3. 递归和分治

递归：在函数的定义中使用函数自身的方法，或通过重复将问题分解为同类的子问题而解决问题的方法

递归的要点：确定递归边界，避免死递归。减小递归深度，避免爆栈。

递归模板：

``` C++
int recursion(int arg)
{
    if (/*递归边界条件*/)
        return /*最小子问题解*/;
    return recursion(/*子问题的参数*/);
}
```

分治：分治算法的核心思想就是“分而治之”。

大概的流程可以分为三步：分解 -> 解决 -> 合并。

1. 分解原问题为结构相同的子问题。
2. 分解到某个容易求解的边界之后，进行递归求解。
3. 将子问题的解合并成原问题的解。

分治法能解决的问题一般有如下特征：

- 该问题的规模缩小到一定的程度就可以容易地解决。

- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。

- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

``` C++
int conquer()
{
   if (/*达到问题的最小规模*/)
       return /*最小子问题的解*/;
    
}
```



### 6. 前缀和&差分

用于预处理数列，可以降低查询的时间复杂度。

前缀和即“数列的前n项和”





（挖坑待填:sleeping:）

## 一. 搜索

### 1. 深度优先搜索（非图论）

使用栈保存未被检测的状态，状态按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。

本质上是一种~~优雅的~~枚举。DFS使用递归，隐含地使用了系统的栈，不需要自己维护一个数据结构。

时间复杂度较高但空间复杂度较低，可以进行优化。

基本结构：

``` C++
void dfs(int step)
{
    //判断是否满足结束条件
    if (/*结果判断*/)
    {
        /*输出解*/
        return;
    }
    //循环枚举待验证解
    for(int i(0) ; i < /*需要枚举的节点总数*/ ; i++)
    {
        if (mark[i] == false && /*是否满足进入下一层的条件*/)
        {
        	mark[i] = true;		//标记枚举过的节点
        	dfs(step+1);		//进行下一层枚举
        	mark[i] = false;	//还原枚举过的节点
        }
    }
    return;
}
```

优点：能找出所有方案，代码比BFS简洁许多。

缺点：在搜索层数较深的情况下时间复杂度高，递归过深容易爆栈

优化方法：

[^1]: 参考文章：[浅谈搜索剪枝 - Fenghr - 博客园 (cnblogs.com)](https://www.cnblogs.com/fenghaoran/p/6391016.html)

1. 可行性剪枝：

   当前条件不合法时就不再继续搜索，直接`return;`

2. 最优性剪枝：

   利用某个函数估计出此时条件下答案的当前最值，如果当前条件所花费的代价已经超过了当前搜索到的最优解，那么剩下的搜索就可以剪掉。

3. 记忆化搜索：

   如果对于相同情况下答案相同的情况，可以先把这个情况的答案存储下来，以后搜索时直接调用，避免重复搜索。

4. 搜索顺序剪枝

   预先估计搜索效率最高的顺序，从效率最高处开始搜索。

   迷宫、网格类：从出口向入口搜索

   推断搜索类：从已知信息最多的地方开始搜索
   
### 2. 广度优先搜索（非图论）

​	使用队列来保存未被检测的状态。状态按照宽度优先的顺序被访问和进出队列。

``` C++
queue ;

void bfs()
{
    int 
   
```



（详见图论BFS :hole: )

### 3. 双向搜索

1.双向BFS

双向BFS适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个BFS的搜索效率

双向BFS的步骤

``` c++
void double_end_DFS()
{
    int mark[/*节点总量*/] = {0};
    q.push_back(/*从开始节点到目标节点*/)
    mark[/*开始节点*/] = 1;
    mark[/*目标结点*/] = 2;
    while (!q.empty())
    {
      //从 q.front() 扩展出新的 s 个结点

      如果 新扩展出的结点已经被其他数字标记过
        那么 表示搜索的两端碰撞
        那么 循环结束

      如果 新的 s 个结点是从开始结点扩展来的
        那么 将这个 s 个结点标记为 1 并且入队 q 

      如果 新的 s 个结点是从目标结点扩展来的
        那么 将这个 s 个结点标记为 2 并且入队 q
    }
}
```



## 二.动态规划

### 0.动态规划基础



### 1.背包DP

#### (1) 0-1背包

**已知条件：**第 $i$ 个物品的重量 $w_i$ 和价值 $v_i$ ，以及背包的总容量 $W$

**要求：**选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量

**方法：**

* 设DP状态 $f_{i}$ 为在第 $i$ 个状态下背包中物品所能达到的最大总价值，$j_i$ 为在第 $i$ 个状态下背包的剩余容量

使用递归进行状态转移：

----

每一个状态包括两种情况：选择当前物品和不选择当前物品

* 设已得到前 $i-1$ 个状态的最优解 $f_{i-1}$

对于第 $i$ 个物品，<u>在背包容量大于其重量的前提下</u>

当其不被选择时，背包的剩余容量和其中物品的总价值不变，该情况的背包中物品的总价值为 $f_{i-1}$，剩余容量容量为 $ j_{i-1} $

当其被选择时，背包的剩余容量减少 $w_i$ ，其中物品的总价值增加 $v_i$ ，该情况的背包中物品的总价值为 $f_{i-1} + v_i$，剩余容量为 $j_{i-1} - w_i$

则当前状态的最优解为两种情况中的最大值，即~~状态转移方程~~
$$
f_i = max(f_{i-1} , f_{i-1}+v_i)
$$


$$
j_i = \left\{
\begin{array}{}
j_{i-1} &,& f_{i-1} > f_{i-1} + v_i  \\
j_{i-1} + v_i &,& f_{i-1} <  f_{i-1}+v_i
\end{array}
\right.
$$

当递归完成后，所得结果则为整体的最优解

----

基本结构：

```c++
int dp(int )
{
    
}
```



#### (2) 完全背包

